{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to spatial_tda","text":"<p>Python Boilerplate contains all the boilerplate you need to create a Python package.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://hashansl.github.io/spatial_tda</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"adjacency_simplex/","title":"adjacency_simplex module","text":"<p>A class to process a GeoDataFrame, filter and sort it based on a variable,  compute adjacency relationships, and form a simplicial complex.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>class AdjacencySimplex:\n    \"\"\"\n    A class to process a GeoDataFrame, filter and sort it based on a variable, \n    compute adjacency relationships, and form a simplicial complex.\n    \"\"\"\n\n    def __init__(self, gdf, variable, threshold=None, filter_method='up'):\n        \"\"\"\n        Initialize with a GeoDataFrame.\n\n        Parameters:\n        - gdf: GeoDataFrame containing geographic and attribute data.\n        - variable: Column name used for filtering and sorting.\n        - threshold: Tuple (min, max) for filtering values within a range.\n        - filter_method: Sorting method, either 'up' (descending) or 'down' (ascending).\n        \"\"\"\n        self.gdf = gdf\n        self.variable = variable\n        self.filter_method = filter_method\n        self.threshold = threshold\n\n    def filter_sort_gdf(self):\n        \"\"\"\n        Filter and sort the GeoDataFrame based on the specified variable and method.\n        \"\"\"\n        gdf = self.gdf.copy()\n\n        # Sort the DataFrame based on the specified method\n        if self.filter_method == 'up':\n            gdf = gdf.sort_values(by=self.variable, ascending=True)\n        elif self.filter_method == 'down':\n            # get the max value\n            max_value = gdf[self.variable].max()\n            # invert the values - Assuming negative values are not present\n            gdf[self.variable] = max_value - gdf[self.variable]\n            gdf = gdf.sort_values(by=self.variable, ascending=True)\n        else:\n            raise ValueError(\"Invalid filter method. Use 'up' or 'down'.\")\n\n        # this need to be done before filtering\n        gdf['sortedID'] = range(len(gdf))\n\n        # this for the below filter\n        filtered_df = gdf.copy()\n\n        # Apply threshold filtering if specified\n        if self.threshold:\n            filtered_df = filtered_df[(filtered_df[self.variable] &gt;= self.threshold[0]) &amp;\n                                      (filtered_df[self.variable] &lt;= self.threshold[1])]\n\n        # Convert DataFrame to GeoDataFrame\n        filtered_df = gpd.GeoDataFrame(filtered_df, geometry='geometry')\n\n        # Set Coordinate Reference System (CRS)\n        filtered_df.crs = \"EPSG:4326\"\n\n        self.filtered_df = filtered_df\n\n        # this returns a filtered dataframe and the original dataframe with the sortedID\n        return filtered_df, gdf\n\n    def calculate_adjacent_countries(self):\n        \"\"\"\n        Compute adjacency relationships between geographic entities.\n        \"\"\"\n        # Ensure filter_sort_gdf() has been executed\n        if not hasattr(self, 'filtered_df') or not isinstance(self.filtered_df, gpd.GeoDataFrame):\n            raise ValueError(\"Run filter_sort_gdf() before calling this method.\")\n\n        # Perform spatial join to find adjacent entities\n        adjacent_entities = gpd.sjoin(self.filtered_df, self.filtered_df, predicate='intersects', how='left')\n\n        # Remove self-intersections\n        adjacent_entities = adjacent_entities.query('sortedID_left != sortedID_right')\n\n        # Group by entity and store adjacent entities in a list\n        adjacent_entities = adjacent_entities.groupby('sortedID_left')['sortedID_right'].apply(list).reset_index()\n        adjacent_entities.rename(columns={'sortedID_left': 'county', 'sortedID_right': 'adjacent'}, inplace=True)\n\n        # Create adjacency dictionary\n        adjacent_dict = dict(zip(adjacent_entities['county'], adjacent_entities['adjacent']))\n\n        # Merge adjacency information with the original dataset\n        merged_df = pd.merge(adjacent_entities, self.filtered_df, left_on='county', right_on='sortedID', how='left')\n\n        # Convert to GeoDataFrame\n        merged_df = gpd.GeoDataFrame(merged_df, geometry='geometry')\n        merged_df.crs = \"EPSG:4326\"\n\n        # Store results\n        self.adjacent_counties_dict = adjacent_dict\n        self.merged_df = merged_df\n\n    def form_simplicial_complex(self):\n        \"\"\"\n        Construct a simplicial complex using adjacency relationships.\n        \"\"\"\n        if not hasattr(self, 'adjacent_counties_dict'):\n            raise ValueError(\"Run calculate_adjacent_countries() before calling this method.\")\n\n        max_dimension = 3  # Define maximum dimension for the simplicial complex\n        simplicial_complex = invr.incremental_vr([], self.adjacent_counties_dict, max_dimension, list(self.adjacent_counties_dict.keys()))\n\n        return simplicial_complex\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.__init__","title":"<code>__init__(self, gdf, variable, threshold=None, filter_method='up')</code>  <code>special</code>","text":"<p>Initialize with a GeoDataFrame.</p> <ul> <li>gdf: GeoDataFrame containing geographic and attribute data.</li> <li>variable: Column name used for filtering and sorting.</li> <li>threshold: Tuple (min, max) for filtering values within a range.</li> <li>filter_method: Sorting method, either 'up' (descending) or 'down' (ascending).</li> </ul> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def __init__(self, gdf, variable, threshold=None, filter_method='up'):\n    \"\"\"\n    Initialize with a GeoDataFrame.\n\n    Parameters:\n    - gdf: GeoDataFrame containing geographic and attribute data.\n    - variable: Column name used for filtering and sorting.\n    - threshold: Tuple (min, max) for filtering values within a range.\n    - filter_method: Sorting method, either 'up' (descending) or 'down' (ascending).\n    \"\"\"\n    self.gdf = gdf\n    self.variable = variable\n    self.filter_method = filter_method\n    self.threshold = threshold\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.calculate_adjacent_countries","title":"<code>calculate_adjacent_countries(self)</code>","text":"<p>Compute adjacency relationships between geographic entities.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def calculate_adjacent_countries(self):\n    \"\"\"\n    Compute adjacency relationships between geographic entities.\n    \"\"\"\n    # Ensure filter_sort_gdf() has been executed\n    if not hasattr(self, 'filtered_df') or not isinstance(self.filtered_df, gpd.GeoDataFrame):\n        raise ValueError(\"Run filter_sort_gdf() before calling this method.\")\n\n    # Perform spatial join to find adjacent entities\n    adjacent_entities = gpd.sjoin(self.filtered_df, self.filtered_df, predicate='intersects', how='left')\n\n    # Remove self-intersections\n    adjacent_entities = adjacent_entities.query('sortedID_left != sortedID_right')\n\n    # Group by entity and store adjacent entities in a list\n    adjacent_entities = adjacent_entities.groupby('sortedID_left')['sortedID_right'].apply(list).reset_index()\n    adjacent_entities.rename(columns={'sortedID_left': 'county', 'sortedID_right': 'adjacent'}, inplace=True)\n\n    # Create adjacency dictionary\n    adjacent_dict = dict(zip(adjacent_entities['county'], adjacent_entities['adjacent']))\n\n    # Merge adjacency information with the original dataset\n    merged_df = pd.merge(adjacent_entities, self.filtered_df, left_on='county', right_on='sortedID', how='left')\n\n    # Convert to GeoDataFrame\n    merged_df = gpd.GeoDataFrame(merged_df, geometry='geometry')\n    merged_df.crs = \"EPSG:4326\"\n\n    # Store results\n    self.adjacent_counties_dict = adjacent_dict\n    self.merged_df = merged_df\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.filter_sort_gdf","title":"<code>filter_sort_gdf(self)</code>","text":"<p>Filter and sort the GeoDataFrame based on the specified variable and method.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def filter_sort_gdf(self):\n    \"\"\"\n    Filter and sort the GeoDataFrame based on the specified variable and method.\n    \"\"\"\n    gdf = self.gdf.copy()\n\n    # Sort the DataFrame based on the specified method\n    if self.filter_method == 'up':\n        gdf = gdf.sort_values(by=self.variable, ascending=True)\n    elif self.filter_method == 'down':\n        # get the max value\n        max_value = gdf[self.variable].max()\n        # invert the values - Assuming negative values are not present\n        gdf[self.variable] = max_value - gdf[self.variable]\n        gdf = gdf.sort_values(by=self.variable, ascending=True)\n    else:\n        raise ValueError(\"Invalid filter method. Use 'up' or 'down'.\")\n\n    # this need to be done before filtering\n    gdf['sortedID'] = range(len(gdf))\n\n    # this for the below filter\n    filtered_df = gdf.copy()\n\n    # Apply threshold filtering if specified\n    if self.threshold:\n        filtered_df = filtered_df[(filtered_df[self.variable] &gt;= self.threshold[0]) &amp;\n                                  (filtered_df[self.variable] &lt;= self.threshold[1])]\n\n    # Convert DataFrame to GeoDataFrame\n    filtered_df = gpd.GeoDataFrame(filtered_df, geometry='geometry')\n\n    # Set Coordinate Reference System (CRS)\n    filtered_df.crs = \"EPSG:4326\"\n\n    self.filtered_df = filtered_df\n\n    # this returns a filtered dataframe and the original dataframe with the sortedID\n    return filtered_df, gdf\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.form_simplicial_complex","title":"<code>form_simplicial_complex(self)</code>","text":"<p>Construct a simplicial complex using adjacency relationships.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def form_simplicial_complex(self):\n    \"\"\"\n    Construct a simplicial complex using adjacency relationships.\n    \"\"\"\n    if not hasattr(self, 'adjacent_counties_dict'):\n        raise ValueError(\"Run calculate_adjacent_countries() before calling this method.\")\n\n    max_dimension = 3  # Define maximum dimension for the simplicial complex\n    simplicial_complex = invr.incremental_vr([], self.adjacent_counties_dict, max_dimension, list(self.adjacent_counties_dict.keys()))\n\n    return simplicial_complex\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v005-date","title":"v0.0.5 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#spatial_tda.common.add","title":"<code>add(a, b)</code>","text":"<p>Adds two numbers together.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>The first number.</p> required <code>b</code> <code>int</code> <p>The second number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum of the two numbers.</p> Source code in <code>spatial_tda/common.py</code> <pre><code>def add(a, b):\n    \"\"\"Adds two numbers together.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        int: The sum of the two numbers.\n    \"\"\"\n    return a + b\n</code></pre>"},{"location":"common/#spatial_tda.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>spatial_tda/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\n    \"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/hashansl/spatial-tda/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>spatial-tda could always use more documentation, whether as part of the official spatial-tda docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/hashansl/spatial-tda/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up spatial-tda for local development.</p> <ol> <li> <p>Fork the spatial-tda repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/spatial-tda.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv spatial-tda\n$ cd spatial-tda/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 spatial-tda tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/hashansl/spatial-tda/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install spatial-tda, run this command in your terminal:</p> <pre><code>pip install spatial-tda\n</code></pre> <p>This is the preferred method to install spatial-tda, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install spatial-tda from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/hashansl/spatial-tda\n</code></pre>"},{"location":"spatial_tda/","title":"spatial_tda module","text":"<p>Main module.</p>"},{"location":"usage/","title":"Usage","text":"<p>To use spatial-tda in a project:</p> <pre><code>import spatial_tda\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"}]}