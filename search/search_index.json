{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to spatial-tda","text":"<p>A Python package for Topological Data Analysis(TDA) in spatial data.</p> <ul> <li>GitHub repo: https://github.com/hashansl/spatial-tda</li> </ul> <ul> <li>PyPI: https://pypi.org/project/spatial-tda</li> </ul> <ul> <li>Free software: MIT license</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>Spatial-TDA is a Python package designed for extracting topological information from spatial data with minimal coding. It provides an intuitive framework for applying topological data analysis (TDA) to geospatial datasets, enabling researchers and analysts to explore spatial connectivity, adjacency relationships, and persistent homology efficiently. Built on GeoPandas, Gudhi, and Matplotlib, the package integrates seamless workflows for adjacency detection, simplicial complex construction, and persistent homology computation while maintaining geospatial integrity. With automatic adjacency extraction, Adjacency simplicial complex formation(Filtering up/ Filtering down), and topological visualization tools, Spatial-TDA simplifies geospatial TDA workflows, making it ideal for applications in epidemiology, environmental studies and spatial network analysis. Through a combination of computational efficiency and easy-to-use functions, Spatial-TDA bridges the gap between geospatial analytics and topological insights, enabling users to quantify and visualize higher-order spatial structures** with just a few lines of code.</p>"},{"location":"#usage","title":"Usage","text":"<p>Launch the interactive notebook tutorial for the spatial-tda Python package with Google Colab:(upcoming)</p>"},{"location":"#key-features","title":"Key Features","text":"<p>The AdjacencySimplex class and the compute_persistence function provide a comprehensive framework for processing geospatial data, constructing simplicial complexes, and performing topological data analysis (TDA). These functionalities enable the study of spatial structures and relationships with a focus on spatial adjacency, simplicial complexes, and persistent homology. The key features include:  </p>"},{"location":"#geospatial-data-processing-and-filtering","title":"Geospatial Data Processing and Filtering","text":"<ul> <li>Threshold-based filtering: Users can define minimum and maximum thresholds to focus on specific data ranges.  </li> <li>Geospatial integrity maintenance: The framework ensures that processed data retains its geometric properties and CRS for further spatial analysis.  </li> </ul>"},{"location":"#adjacency-computation-and-simplicial-complex-construction","title":"Adjacency Computation and Simplicial Complex Construction","text":"<ul> <li>Computing adjacency relationships: The class currently uses  the Queen contiguity method to define adjacency, where regions are considered neighbors if they share at least one vertex. However, support for additional adjacency methods will be added soon, providing greater flexibility for geospatial topological analysis.</li> <li>Generating simplicial complexes: The class constructs Adjacency simplicial complexes using adjacency relationships for both filtering up and filtering down methods, enabling higher-order topological analysis with greater flexibility and precision.</li> </ul>"},{"location":"#persistent-homology-and-topological-summaries","title":"Persistent Homology and Topological Summaries","text":"<ul> <li>Computing persistence diagrams: The compute_persistence function constructs a Simplex Tree using Gudhi, assigning filtration values based on the input variable.</li> <li>Topological summaries (TDA metrics): The function computes essential TDA summaries for dimension zero, including:  </li> <li>Total Lifespan (TL): The sum of persistence intervals. </li> <li>Average Lifespan (AL): The mean lifespan of connected components.  </li> <li>Total Mid-Lifespan (TML): The sum of midpoints of persistence intervals.  </li> <li>Average Mid-Lifespan (AML): The average of midpoints of persistence intervals.  </li> </ul>"},{"location":"#efficient-computational-design","title":"Efficient Computational Design","text":"<ul> <li>Optimized spatial computations: The class efficiently processes adjacency relationships, even for large datasets.  </li> <li>Integration with Pandas, GeoPandas, and Gudhi: The framework seamlessly works with popular Python libraries for geospatial and topological data analysis.  </li> <li>Dynamic variable selection: Users can select any numerical attribute to control filtering and sorting.  </li> </ul> <p>These features make the AdjacencySimplex class and compute_persistence function powerful tools for geospatial topological data analysis, helping researchers explore spatial connectivity, adjacency structures, and persistent homology in geospatial datasets. Whether for epidemiology, environmental studies, urban planning, or regional connectivity analysis, this framework provides an intuitive and structured approach to spatial TDA.</p>"},{"location":"#citations","title":"Citations","text":"<p>If you find spatial-tda useful in your research, please consider citing the following paper to support my work. Thank you for your support.</p>"},{"location":"adjacency_simplex/","title":"Adjacency Simplex module","text":"<p>A class to process a GeoDataFrame, filter and sort it based on a variable,  compute adjacency relationships, and form a simplicial complex.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>class AdjacencySimplex:\n    \"\"\"\n    A class to process a GeoDataFrame, filter and sort it based on a variable, \n    compute adjacency relationships, and form a simplicial complex.\n    \"\"\"\n\n    def __init__(self, geo_dataframe, variable, threshold=None, filter_method='up'):\n        \"\"\"\n        Initialize with a GeoDataFrame.\n\n        Parameters:\n        - gdf: GeoDataFrame containing geographic and attribute data.\n        - variable: Column name used for filtering and sorting.\n        - threshold: Tuple (min, max) for filtering values within a range.\n        - filter_method: Sorting method, either 'up' (descending) or 'down' (ascending).\n        \"\"\"\n        self.gdf = geo_dataframe\n        self.variable = variable\n        self.filter_method = filter_method\n        self.threshold = threshold\n        self.filtered_df = None\n        self.adjacent_counties_dict = None\n        self.merged_df = None\n        self.simplicial_complex = None\n\n    def filter_sort_gdf(self,return_original=False,return_filtered=False):\n        \"\"\"\n        Filter and sort the GeoDataFrame based on the specified variable and method.\n        \"\"\"\n        gdf = self.gdf.copy()\n\n        # Sort the DataFrame based on the specified method\n        if self.filter_method == 'up':\n            gdf = gdf.sort_values(by=self.variable, ascending=True)\n        elif self.filter_method == 'down':\n            # get the max value\n            max_value = gdf[self.variable].max()\n            # invert the values - Assuming negative values are not present\n            gdf[self.variable] = max_value - gdf[self.variable]\n            gdf = gdf.sort_values(by=self.variable, ascending=True)\n        else:\n            raise ValueError(\"Invalid filter method. Use 'up' or 'down'.\")\n\n        # this need to be done before filtering\n        gdf['sortedID'] = range(len(gdf))\n\n        # this for the below filter\n        filtered_df = gdf.copy()\n\n        # Apply threshold filtering if specified\n        if self.threshold:\n            filtered_df = filtered_df[(filtered_df[self.variable] &gt;= self.threshold[0]) &amp;\n                                      (filtered_df[self.variable] &lt;= self.threshold[1])]\n\n        # Convert DataFrame to GeoDataFrame\n        filtered_df = gpd.GeoDataFrame(filtered_df, geometry='geometry')\n\n        # Set Coordinate Reference System (CRS)\n        filtered_df.crs = \"EPSG:4326\"\n\n        self.filtered_df = filtered_df\n\n        # this returns a filtered dataframe and the original dataframe with the sortedID\n        if return_original and return_filtered:\n            return gdf, filtered_df\n        elif return_filtered:\n            return filtered_df\n        elif return_original:\n            return gdf\n\n\n    def calculate_adjacent_countries(self):\n        \"\"\"\n        Compute adjacency relationships between geographic entities.\n        \"\"\"\n        # Ensure filter_sort_gdf() has been executed\n        if not hasattr(self, 'filtered_df') or not isinstance(self.filtered_df, gpd.GeoDataFrame):\n            raise ValueError(\"Run filter_sort_gdf() before calling this method.\")\n\n        # Perform spatial join to find adjacent entities\n        adjacent_entities = gpd.sjoin(self.filtered_df, self.filtered_df, predicate='intersects', how='left')\n\n        # Remove self-intersections\n        adjacent_entities = adjacent_entities.query('sortedID_left != sortedID_right')\n\n        # Group by entity and store adjacent entities in a list\n        adjacent_entities = adjacent_entities.groupby('sortedID_left')['sortedID_right'].apply(list).reset_index()\n        adjacent_entities.rename(columns={'sortedID_left': 'county', 'sortedID_right': 'adjacent'}, inplace=True)\n\n        # Create adjacency dictionary\n        adjacent_dict = dict(zip(adjacent_entities['county'], adjacent_entities['adjacent']))\n\n        # Merge adjacency information with the original dataset\n        merged_df = pd.merge(adjacent_entities, self.filtered_df, left_on='county', right_on='sortedID', how='left')\n\n        # Convert to GeoDataFrame\n        merged_df = gpd.GeoDataFrame(merged_df, geometry='geometry')\n        merged_df.crs = \"EPSG:4326\"\n\n        # Store results\n        self.adjacent_counties_dict = adjacent_dict\n        self.merged_df = merged_df\n\n    def form_simplicial_complex(self,return_simplicial_complex=False):\n        \"\"\"\n        Construct a simplicial complex using adjacency relationships.\n        \"\"\"\n        if not hasattr(self, 'adjacent_counties_dict'):\n            raise ValueError(\"Run calculate_adjacent_countries() before calling this method.\")\n\n        max_dimension = 3  # Define maximum dimension for the simplicial complex\n        simplicial_complex = invr.incremental_vr([], self.adjacent_counties_dict, max_dimension, list(self.adjacent_counties_dict.keys()))\n\n        self.simplicial_complex = simplicial_complex\n\n        if return_simplicial_complex:\n            return simplicial_complex\n\n\n    def compute_persistence(self, summaries=None):\n        \"\"\"\n        Compute persistence diagrams for the simplicial complex and return selected topological summaries.\n\n        :param summaries: List of summary names to return (e.g., [\"H0\", \"TL\", \"AL\"]). If None, return all.\n        :return: Dictionary with requested summaries.\n        \"\"\"\n\n        st = gudhi.SimplexTree()\n        st.set_dimension(2)\n\n        for simplex in self.simplicial_complex:\n            if len(simplex) == 1:\n                st.insert([simplex[0]], filtration=0.0)\n\n        for simplex in self.simplicial_complex:\n            if len(simplex) == 2:\n                last_simplex = simplex[-1]\n                filtration_value = self.filtered_df.loc[\n                    self.filtered_df['sortedID'] == last_simplex, self.variable\n                ].values[0]\n                st.insert(simplex, filtration=filtration_value)\n\n        for simplex in self.simplicial_complex:\n            if len(simplex) == 3:\n                last_simplex = simplex[-1]\n                filtration_value = self.filtered_df.loc[\n                    self.filtered_df['sortedID'] == last_simplex, self.variable\n                ].values[0]\n                st.insert(simplex, filtration=filtration_value)\n\n        st.compute_persistence()\n        persistence = st.persistence()\n\n        intervals_dim0 = st.persistence_intervals_in_dimension(0)\n\n        # Replace infinity with the max variable value\n        max_value = self.filtered_df[self.variable].max()\n        intervals_dim0[:, 1][np.isinf(intervals_dim0[:, 1])] = max_value\n\n        # Compute topological summaries\n        H0_data_points = len(intervals_dim0)\n        TL = sum(interval[1] - interval[0] for interval in intervals_dim0)\n        TML = sum((interval[1] + interval[0]) / 2 for interval in intervals_dim0)\n\n        AL = TL / len(intervals_dim0) if len(intervals_dim0) &gt; 0 else 0\n        AML = TML / len(intervals_dim0) if len(intervals_dim0) &gt; 0 else 0\n\n        # Store results in a dictionary\n        results = {\n            \"H0\": H0_data_points,\n            \"TL\": TL,\n            \"AL\": AL,\n            \"TML\": TML,\n            \"AML\": AML,\n        }\n\n        # Return only requested summaries\n        if summaries:\n            return {key: results[key] for key in summaries if key in results}\n        return results  # Default: return all summaries\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.__init__","title":"<code>__init__(self, geo_dataframe, variable, threshold=None, filter_method='up')</code>  <code>special</code>","text":"<p>Initialize with a GeoDataFrame.</p> <ul> <li>gdf: GeoDataFrame containing geographic and attribute data.</li> <li>variable: Column name used for filtering and sorting.</li> <li>threshold: Tuple (min, max) for filtering values within a range.</li> <li>filter_method: Sorting method, either 'up' (descending) or 'down' (ascending).</li> </ul> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def __init__(self, geo_dataframe, variable, threshold=None, filter_method='up'):\n    \"\"\"\n    Initialize with a GeoDataFrame.\n\n    Parameters:\n    - gdf: GeoDataFrame containing geographic and attribute data.\n    - variable: Column name used for filtering and sorting.\n    - threshold: Tuple (min, max) for filtering values within a range.\n    - filter_method: Sorting method, either 'up' (descending) or 'down' (ascending).\n    \"\"\"\n    self.gdf = geo_dataframe\n    self.variable = variable\n    self.filter_method = filter_method\n    self.threshold = threshold\n    self.filtered_df = None\n    self.adjacent_counties_dict = None\n    self.merged_df = None\n    self.simplicial_complex = None\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.calculate_adjacent_countries","title":"<code>calculate_adjacent_countries(self)</code>","text":"<p>Compute adjacency relationships between geographic entities.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def calculate_adjacent_countries(self):\n    \"\"\"\n    Compute adjacency relationships between geographic entities.\n    \"\"\"\n    # Ensure filter_sort_gdf() has been executed\n    if not hasattr(self, 'filtered_df') or not isinstance(self.filtered_df, gpd.GeoDataFrame):\n        raise ValueError(\"Run filter_sort_gdf() before calling this method.\")\n\n    # Perform spatial join to find adjacent entities\n    adjacent_entities = gpd.sjoin(self.filtered_df, self.filtered_df, predicate='intersects', how='left')\n\n    # Remove self-intersections\n    adjacent_entities = adjacent_entities.query('sortedID_left != sortedID_right')\n\n    # Group by entity and store adjacent entities in a list\n    adjacent_entities = adjacent_entities.groupby('sortedID_left')['sortedID_right'].apply(list).reset_index()\n    adjacent_entities.rename(columns={'sortedID_left': 'county', 'sortedID_right': 'adjacent'}, inplace=True)\n\n    # Create adjacency dictionary\n    adjacent_dict = dict(zip(adjacent_entities['county'], adjacent_entities['adjacent']))\n\n    # Merge adjacency information with the original dataset\n    merged_df = pd.merge(adjacent_entities, self.filtered_df, left_on='county', right_on='sortedID', how='left')\n\n    # Convert to GeoDataFrame\n    merged_df = gpd.GeoDataFrame(merged_df, geometry='geometry')\n    merged_df.crs = \"EPSG:4326\"\n\n    # Store results\n    self.adjacent_counties_dict = adjacent_dict\n    self.merged_df = merged_df\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.compute_persistence","title":"<code>compute_persistence(self, summaries=None)</code>","text":"<p>Compute persistence diagrams for the simplicial complex and return selected topological summaries.</p> <p>:param summaries: List of summary names to return (e.g., [\"H0\", \"TL\", \"AL\"]). If None, return all. :return: Dictionary with requested summaries.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def compute_persistence(self, summaries=None):\n    \"\"\"\n    Compute persistence diagrams for the simplicial complex and return selected topological summaries.\n\n    :param summaries: List of summary names to return (e.g., [\"H0\", \"TL\", \"AL\"]). If None, return all.\n    :return: Dictionary with requested summaries.\n    \"\"\"\n\n    st = gudhi.SimplexTree()\n    st.set_dimension(2)\n\n    for simplex in self.simplicial_complex:\n        if len(simplex) == 1:\n            st.insert([simplex[0]], filtration=0.0)\n\n    for simplex in self.simplicial_complex:\n        if len(simplex) == 2:\n            last_simplex = simplex[-1]\n            filtration_value = self.filtered_df.loc[\n                self.filtered_df['sortedID'] == last_simplex, self.variable\n            ].values[0]\n            st.insert(simplex, filtration=filtration_value)\n\n    for simplex in self.simplicial_complex:\n        if len(simplex) == 3:\n            last_simplex = simplex[-1]\n            filtration_value = self.filtered_df.loc[\n                self.filtered_df['sortedID'] == last_simplex, self.variable\n            ].values[0]\n            st.insert(simplex, filtration=filtration_value)\n\n    st.compute_persistence()\n    persistence = st.persistence()\n\n    intervals_dim0 = st.persistence_intervals_in_dimension(0)\n\n    # Replace infinity with the max variable value\n    max_value = self.filtered_df[self.variable].max()\n    intervals_dim0[:, 1][np.isinf(intervals_dim0[:, 1])] = max_value\n\n    # Compute topological summaries\n    H0_data_points = len(intervals_dim0)\n    TL = sum(interval[1] - interval[0] for interval in intervals_dim0)\n    TML = sum((interval[1] + interval[0]) / 2 for interval in intervals_dim0)\n\n    AL = TL / len(intervals_dim0) if len(intervals_dim0) &gt; 0 else 0\n    AML = TML / len(intervals_dim0) if len(intervals_dim0) &gt; 0 else 0\n\n    # Store results in a dictionary\n    results = {\n        \"H0\": H0_data_points,\n        \"TL\": TL,\n        \"AL\": AL,\n        \"TML\": TML,\n        \"AML\": AML,\n    }\n\n    # Return only requested summaries\n    if summaries:\n        return {key: results[key] for key in summaries if key in results}\n    return results  # Default: return all summaries\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.filter_sort_gdf","title":"<code>filter_sort_gdf(self, return_original=False, return_filtered=False)</code>","text":"<p>Filter and sort the GeoDataFrame based on the specified variable and method.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def filter_sort_gdf(self,return_original=False,return_filtered=False):\n    \"\"\"\n    Filter and sort the GeoDataFrame based on the specified variable and method.\n    \"\"\"\n    gdf = self.gdf.copy()\n\n    # Sort the DataFrame based on the specified method\n    if self.filter_method == 'up':\n        gdf = gdf.sort_values(by=self.variable, ascending=True)\n    elif self.filter_method == 'down':\n        # get the max value\n        max_value = gdf[self.variable].max()\n        # invert the values - Assuming negative values are not present\n        gdf[self.variable] = max_value - gdf[self.variable]\n        gdf = gdf.sort_values(by=self.variable, ascending=True)\n    else:\n        raise ValueError(\"Invalid filter method. Use 'up' or 'down'.\")\n\n    # this need to be done before filtering\n    gdf['sortedID'] = range(len(gdf))\n\n    # this for the below filter\n    filtered_df = gdf.copy()\n\n    # Apply threshold filtering if specified\n    if self.threshold:\n        filtered_df = filtered_df[(filtered_df[self.variable] &gt;= self.threshold[0]) &amp;\n                                  (filtered_df[self.variable] &lt;= self.threshold[1])]\n\n    # Convert DataFrame to GeoDataFrame\n    filtered_df = gpd.GeoDataFrame(filtered_df, geometry='geometry')\n\n    # Set Coordinate Reference System (CRS)\n    filtered_df.crs = \"EPSG:4326\"\n\n    self.filtered_df = filtered_df\n\n    # this returns a filtered dataframe and the original dataframe with the sortedID\n    if return_original and return_filtered:\n        return gdf, filtered_df\n    elif return_filtered:\n        return filtered_df\n    elif return_original:\n        return gdf\n</code></pre>"},{"location":"adjacency_simplex/#spatial_tda.adjacency_simplex.AdjacencySimplex.form_simplicial_complex","title":"<code>form_simplicial_complex(self, return_simplicial_complex=False)</code>","text":"<p>Construct a simplicial complex using adjacency relationships.</p> Source code in <code>spatial_tda/adjacency_simplex.py</code> <pre><code>def form_simplicial_complex(self,return_simplicial_complex=False):\n    \"\"\"\n    Construct a simplicial complex using adjacency relationships.\n    \"\"\"\n    if not hasattr(self, 'adjacent_counties_dict'):\n        raise ValueError(\"Run calculate_adjacent_countries() before calling this method.\")\n\n    max_dimension = 3  # Define maximum dimension for the simplicial complex\n    simplicial_complex = invr.incremental_vr([], self.adjacent_counties_dict, max_dimension, list(self.adjacent_counties_dict.keys()))\n\n    self.simplicial_complex = simplicial_complex\n\n    if return_simplicial_complex:\n        return simplicial_complex\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v005-date","title":"v0.0.5 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#spatial_tda.common.add","title":"<code>add(a, b)</code>","text":"<p>Adds two numbers together.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>The first number.</p> required <code>b</code> <code>int</code> <p>The second number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum of the two numbers.</p> Source code in <code>spatial_tda/common.py</code> <pre><code>def add(a, b):\n    \"\"\"Adds two numbers together.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        int: The sum of the two numbers.\n    \"\"\"\n    return a + b\n</code></pre>"},{"location":"common/#spatial_tda.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>spatial_tda/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\n    \"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/hashansl/spatial-tda/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>spatial-tda could always use more documentation, whether as part of the official spatial-tda docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/hashansl/spatial-tda/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up spatial-tda for local development.</p> <ol> <li> <p>Fork the spatial-tda repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/spatial-tda.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv spatial-tda\n$ cd spatial-tda/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 spatial-tda tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/hashansl/spatial-tda/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"get-started/","title":"Get Started","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install spatial-tda, run this command in your terminal:</p> <pre><code>pip install spatial-tda\n</code></pre> <p>This is the preferred method to install spatial-tda, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install spatial-tda from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/hashansl/spatial-tda\n</code></pre>"},{"location":"spatial_tda/","title":"spatial_tda module","text":"<p>Main module.</p>"},{"location":"usage/","title":"Usage","text":"<p>To use spatial-tda in a project:</p> <pre><code>import spatial_tda\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"},{"location":"notebooks/00_key_features/","title":"Usage","text":"In\u00a0[\u00a0]: Copied!"},{"location":"notebooks/00_key_features/#key-features","title":"Key Features\u00b6","text":"<p>This page is updating. Navigate to notebooks for more information.</p>"},{"location":"notebooks/00_key_features/#extracting-topological-features-from-spatial-data","title":"Extracting Topological Features from Spatial Data\u00b6","text":""},{"location":"notebooks/00_key_features/#visualizing-adjacency-simplicial-complexes-in-maps","title":"Visualizing Adjacency Simplicial Complexes in Maps\u00b6","text":""},{"location":"notebooks/01_spatial_tda_intro/","title":"01 spatial tda intro","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install spatial-tda\n</pre> # !pip install spatial-tda <p>Currently, this package only supports spatial datasets with polygonal geometries, as the adjacency module is designed to rely on shared boundaries between polygons to construct adjacency simplicial complexes. This structure is essential for accurately capturing spatial relationships and computing topological summaries. Datasets containing point or line geometries are not compatible, as they lack the necessary boundary-sharing properties required for the adjacency-based analysis.</p> <ul> <li><code>import spatial_tda as tda</code></li> </ul>"},{"location":"notebooks/01_spatial_tda_intro/#introducing-the-spatial-tda-python-package-for-spatial-topological-data-analysis","title":"Introducing the spatial-tda Python package for Spatial Topological Data Analysis\u00b6","text":"<p>Uncomment the following line to install spatial-tda if needed.</p>"},{"location":"notebooks/01_spatial_tda_intro/#module-overview","title":"Module Overview\u00b6","text":"<ul> <li>Adjacency Simplex: Construct adjacency simplicial complexes from polygonal datasets.<ul> <li>Topological Summaries: Compute topological summaries for simplicial complexes.</li> </ul> </li> <li>Future Work: Extend the package to support point and line geometries.</li> </ul>"},{"location":"notebooks/02_adjacency_simplex/","title":"02 adjacency simplex","text":"In\u00a0[1]: Copied! <pre># !pip install -U spatial-tda\n</pre> # !pip install -U spatial-tda In\u00a0[2]: Copied! <pre>import geopandas as gpd\nimport matplotlib.pyplot as plt\n</pre> import geopandas as gpd import matplotlib.pyplot as plt In\u00a0[14]: Copied! <pre># arlington_svi = gpd.read_file(\"https://github.com/hashansl/spatial-tda/tree/main/docs/data/Arlington_SVI2018.gdb\")\n</pre> # arlington_svi = gpd.read_file(\"https://github.com/hashansl/spatial-tda/tree/main/docs/data/Arlington_SVI2018.gdb\") In\u00a0[4]: Copied! <pre>arlington_svi.head(2)\n</pre> arlington_svi.head(2) Out[4]: FIPS EP_POV EP_UNEMP EP_PCI EP_NOHSDP EP_UNINSUR EP_AGE65 EP_AGE17 EP_DISABL EP_SNGPNT EP_LIMENG EP_MINRTY EP_MUNIT EP_MOBILE EP_CROWD EP_NOVEH EP_GROUPQ geometry 0 51013100100 1.2 2.1 76748.0 1.4 1.9 13.6 29.6 5.7 6.4 2.3 23.4 0.5 0.0 0.0 0.6 0.2 POLYGON ((-77.16811 38.89652, -77.16421 38.899... 1 51013100200 1.5 2.0 94706.0 0.1 1.9 15.9 29.9 4.9 2.3 2.5 14.4 0.7 0.0 0.0 2.0 0.1 POLYGON ((-77.15968 38.90315, -77.15454 38.907... In\u00a0[5]: Copied! <pre># plot the data for EP_POV in a geopandas plot\narlington_svi.plot(column='EP_POV', legend=True)\nplt.show()\n</pre> # plot the data for EP_POV in a geopandas plot arlington_svi.plot(column='EP_POV', legend=True) plt.show() In\u00a0[6]: Copied! <pre># import the library\nimport spatial_tda as tda\n</pre> # import the library import spatial_tda as tda In\u00a0[7]: Copied! <pre>adjacency_simplex = tda.AdjacencySimplex(geo_dataframe=arlington_svi, variable = \"EP_POV\", threshold=None, filter_method='up')\n</pre> adjacency_simplex = tda.AdjacencySimplex(geo_dataframe=arlington_svi, variable = \"EP_POV\", threshold=None, filter_method='up') In\u00a0[8]: Copied! <pre>adjacency_simplex.filter_sort_gdf()\n</pre> adjacency_simplex.filter_sort_gdf() In\u00a0[9]: Copied! <pre>adjacency_simplex.calculate_adjacent_countries()\n</pre> adjacency_simplex.calculate_adjacent_countries() In\u00a0[10]: Copied! <pre>adjacency_simplex.form_simplicial_complex()\n</pre> adjacency_simplex.form_simplicial_complex() In\u00a0[11]: Copied! <pre>summaries = adjacency_simplex.compute_persistence()\n</pre> summaries = adjacency_simplex.compute_persistence() In\u00a0[12]: Copied! <pre>print(summaries)\n</pre> print(summaries) <pre>{'H0': 57, 'TL': 435.9000000000001, 'AL': 7.647368421052633, 'TML': 217.95000000000005, 'AML': 3.8236842105263165}\n</pre>"},{"location":"notebooks/02_adjacency_simplex/#adjacency-simplicial-complex-module","title":"Adjacency Simplicial Complex Module\u00b6","text":"<p>You can try out spatial-tda by using the cloud-computing platforms below without having to install anything on your computer:</p>"},{"location":"notebooks/02_adjacency_simplex/#installation","title":"Installation\u00b6","text":"<p>To install spatial_tda, use:</p>"},{"location":"notebooks/02_adjacency_simplex/#import-libraries","title":"Import Libraries\u00b6","text":""},{"location":"notebooks/02_adjacency_simplex/#import-geospatial-data-for-the-analysis","title":"Import Geospatial Data for the Analysis\u00b6","text":""},{"location":"notebooks/02_adjacency_simplex/#adjacency-simplicial-complex-module","title":"Adjacency Simplicial Complex Module\u00b6","text":"<p>The adjacency module provides tools for constructing adjacency-based simplicial complexes and extracting relevant topological summaries.</p>"},{"location":"notebooks/02_adjacency_simplex/#key-features","title":"Key Features\u00b6","text":"<ul> <li>Constructing adjacency-based simplicial complexes</li> <li>Extracting topological summaries</li> <li>Visualizing simplicial complexes (Under development)</li> </ul>"},{"location":"notebooks/02_adjacency_simplex/#create-the-adjacency-simplicial-complex-object-from-the-geospatial-data","title":"Create the Adjacency Simplicial Complex Object from the Geospatial Data\u00b6","text":""},{"location":"notebooks/02_adjacency_simplex/#filter-and-sort-the-variable","title":"Filter and sort the Variable\u00b6","text":""},{"location":"notebooks/02_adjacency_simplex/#calculate-the-adjacent-countiescensus-tracts","title":"Calculate the Adjacent Counties/Census Tracts\u00b6","text":""},{"location":"notebooks/02_adjacency_simplex/#create-the-simplicial-complex-using-the-adjacency-matrix","title":"Create the Simplicial Complex using the Adjacency Matrix\u00b6","text":""},{"location":"notebooks/02_adjacency_simplex/#calculate-the-persistent-homology-and-get-the-tda-summary-for-the-study-areaarlington-county-va","title":"Calculate the Persistent Homology and get the TDA summary for the study area(Arlington County, VA)\u00b6","text":""}]}